/**
 * @file
 * @brief Autogenerated RPC command runner
 * @copyright 2024 Embeint Inc
 * @author scripts/west_commands/cloudgen.py
 *
 * SPDX-License-Identifier: LicenseRef-Embeint
 */

#include <stdbool.h>

#include <zephyr/toolchain.h>
#include <zephyr/net/buf.h>
#include <zephyr/logging/log.h>

#include <infuse/epacket/interface.h>
#include <infuse/epacket/packet.h>
#include <infuse/rpc/types.h>
#include <infuse/rpc/server.h>

#include "commands/commands.h"

/* Authorised to run command */
#define AUTHORISED(auth, name) (auth >= CONFIG_INFUSE_RPC_COMMAND_ ## name ## _REQUIRED_AUTH)

static bool command_freed;
static bool response_sent;

LOG_MODULE_DECLARE(rpc_server);

void rpc_command_runner_request_unref(struct net_buf *request)
{
	net_buf_unref(request);
	command_freed = true;
}

void rpc_command_runner_early_response(const struct device *interface, enum epacket_auth auth,
				       uint32_t request_id, uint16_t command_id,
				       struct net_buf *response)
{
	struct infuse_rpc_rsp_header *rsp_header;

	rsp_header = (void *)response->data;
	rsp_header->request_id = request_id;
	rsp_header->command_id = command_id;

	/* Metadata and core response info */
	epacket_set_tx_metadata(response, auth, 0x00, INFUSE_RPC_RSP, EPACKET_ADDR_ALL);

	/* Push response back over incoming interface */
	epacket_queue(interface, response);
	response_sent = true;
}

void rpc_command_runner(struct net_buf *request)
{
	struct epacket_rx_metadata *metadata = net_buf_user_data(request);
	const struct device *interface = metadata->interface;
	struct infuse_rpc_req_header *req_header = (void *)request->data;
	struct infuse_rpc_rsp_header *rsp_header;
	struct net_buf *response = NULL;
	enum epacket_auth auth = metadata->auth;
	uint32_t request_id = req_header->request_id;
	uint16_t command_id = req_header->command_id;
	int16_t rc = -EACCES;

	/* Reset command freed state */
	command_freed = false;
	response_sent = false;

	LOG_DBG("Handling RPC: %d Auth: %d", command_id, auth);

	switch (command_id) {
{% for command in commands.values() %}
#ifdef CONFIG_INFUSE_RPC_COMMAND_{{ command['name'] | upper }}
	case RPC_ID_{{ command['name'] | upper }}:
		if (AUTHORISED(auth, {{ command['name'] | upper }})) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_{{ command['name'] }}(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_{{ command['name'] | upper }} */
{% endfor %}
	default:
#ifdef CONFIG_INFUSE_RPC_SERVER_USER_COMMANDS
		if (command_id > RPC_BUILTIN_END) {
			rc = infuse_rpc_server_user_command_runner(command_id, auth, request, &response);
		} else {
			rc = -ENOTSUP;
		}
#else
		rc = -ENOTSUP;
#endif /* CONFIG_INFUSE_RPC_SERVER_USER_COMMANDS */
	};

	/* Free the request */
	if (!command_freed) {
		net_buf_unref(request);
	}
	if (response_sent) {
		/* Response already run */
		__ASSERT_NO_MSG(response == NULL);
		return;
	}

	if (response == NULL) {
		/* No command run, alloc the response packet */
		response = epacket_alloc_tx_for_interface(interface, K_FOREVER);
		if (net_buf_tailroom(response) == 0) {
			/* Response channel closed */
			net_buf_unref(response);
			return;
		}
		rsp_header = net_buf_add(response, sizeof(*rsp_header));
		rsp_header->return_code = rc;
	} else {
		rsp_header = (void *)response->data;
	}
	rsp_header->request_id = request_id;
	rsp_header->command_id = command_id;

	/* Metadata and core response info */
	epacket_set_tx_metadata(response, auth, 0x00, INFUSE_RPC_RSP, EPACKET_ADDR_ALL);

	/* Push response back over incoming interface */
	epacket_queue(interface, response);
}
