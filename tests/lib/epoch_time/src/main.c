/**
 * @file
 * @copyright 2024 Embeint Holdings Pty Ltd
 * @author Jordan Yates <jordan@embeint.com>
 *
 * SPDX-License-Identifier: FSL-1.1-ALv2
 */

#include <stdint.h>

#include <zephyr/ztest.h>
#include <zephyr/kernel.h>

#include <infuse/time/epoch.h>
#include <infuse/time/timezone.h>
#include <infuse/states.h>

ZTEST(epoch_time, test_time_source_valid)
{
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_NONE, false));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_NONE, true));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_INVALID, false));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_INVALID, true));
	zassert_false(epoch_time_trusted_source(33, false));
	zassert_false(epoch_time_trusted_source(33, true));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NONE, false));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NONE, true));
	zassert_false(
		epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_INVALID, false));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_INVALID, true));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | 33, false));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | 33, true));

	zassert_true(epoch_time_trusted_source(TIME_SOURCE_GNSS, false));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_GNSS, true));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_NTP, false));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_NTP, true));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_RPC, false));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_RPC, true));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_GNSS, false));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_GNSS, true));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NTP, false));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NTP, true));
	zassert_false(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, false));
	zassert_true(epoch_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, true));
}

static void validate_unix_conversions(struct tm *expected, uint64_t gps_time, uint64_t unix_time,
				      uint16_t subseconds)
{
	struct tm calendar;
	uint64_t epoch_time;

	epoch_time = epoch_time_from(gps_time, subseconds);
	zassert_equal(unix_time, unix_time_from_epoch(epoch_time));
	zassert_equal(epoch_time, epoch_time_from_unix(unix_time, subseconds));

	epoch_time_unix_calendar(epoch_time, &calendar);
	zassert_equal(expected->tm_year, calendar.tm_year);
	zassert_equal(expected->tm_mon, calendar.tm_mon);
	zassert_equal(expected->tm_mday, calendar.tm_mday);
	zassert_equal(expected->tm_yday, calendar.tm_yday);
	zassert_equal(expected->tm_hour, calendar.tm_hour);
	zassert_equal(expected->tm_min, calendar.tm_min);
	zassert_equal(expected->tm_sec, calendar.tm_sec);
	zassert_equal(expected->tm_wday, calendar.tm_wday);
}

/* Equivalent times are generated by `hifitime_generator.py`.
 * hifitime is a formally verified time library and should be trusted over websites.
 */
ZTEST(epoch_time, test_unix_conversions)
{
	struct tm expected;

	/* 2017-01-01T00:00:00 UTC */
	expected.tm_year = 117;
	expected.tm_mon = 0;
	expected.tm_mday = 1;
	expected.tm_yday = 0;
	expected.tm_hour = 0;
	expected.tm_min = 0;
	expected.tm_sec = 0;
	expected.tm_wday = 0;
	validate_unix_conversions(&expected, 1167264018, 1483228800, 0);

	/* 2020-01-01T00:00:00 UTC */
	expected.tm_year = 120;
	expected.tm_mon = 0;
	expected.tm_mday = 1;
	expected.tm_yday = 0;
	expected.tm_hour = 0;
	expected.tm_min = 0;
	expected.tm_sec = 0;
	expected.tm_wday = 3;
	validate_unix_conversions(&expected, 1261872018, 1577836800, 0);

	/* 2024-07-02T12:43:01 UTC */
	expected.tm_year = 124;
	expected.tm_mon = 6;
	expected.tm_mday = 2;
	expected.tm_yday = 183;
	expected.tm_hour = 12;
	expected.tm_min = 43;
	expected.tm_sec = 1;
	expected.tm_wday = 2;
	validate_unix_conversions(&expected, 1403959399, 1719924181, 0);

	/* 2024-07-02T12:43:01 UTC + (1324/65536) */
	expected.tm_year = 124;
	expected.tm_mon = 6;
	expected.tm_mday = 2;
	expected.tm_yday = 183;
	expected.tm_hour = 12;
	expected.tm_min = 43;
	expected.tm_sec = 1;
	expected.tm_wday = 2;
	validate_unix_conversions(&expected, 1403959399, 1719924181, 1324);
}

static void validate_internal(uint64_t epoch_time)
{
	uint64_t seconds, subseconds;

	seconds = epoch_time_seconds(epoch_time);
	subseconds = epoch_time_subseconds(epoch_time);

	zassert_not_equal(epoch_time, seconds);
	zassert_not_equal(epoch_time, subseconds);
	zassert_equal(epoch_time, epoch_time_from(seconds, subseconds));
}

ZTEST(epoch_time, test_internal_conversions)
{
	/* Validate at a random time across the whole subsecond range */
	for (int i = 0; i < 100000; i++) {
		validate_internal(12345678910 + i);
	}

	zassert_equal(0, epoch_time_milliseconds(0));
	zassert_equal(0, epoch_time_milliseconds(32));
	zassert_equal(1, epoch_time_milliseconds(33));
	zassert_equal(250, epoch_time_milliseconds((UINT16_MAX + 1) / 4));
	zassert_equal(333, epoch_time_milliseconds((UINT16_MAX + 1) / 3));
	zassert_equal(500, epoch_time_milliseconds((UINT16_MAX + 1) / 2));
	zassert_equal(999, epoch_time_milliseconds(UINT16_MAX - 66));
	zassert_equal(1000, epoch_time_milliseconds(UINT16_MAX));
	zassert_equal(0, epoch_time_milliseconds(UINT16_MAX + 1));
}

ZTEST(epoch_time, test_gps_conversions)
{
	/* Time equivalents generated from https://gnsscalc.com/ */
	zassert_equal(epoch_time_from(1393460764, 0), epoch_time_from_gps(2304, 1564, 0));
	zassert_equal(epoch_time_from(1396138875, 0), epoch_time_from_gps(2308, 260475, 0));
	zassert_equal(epoch_time_from(1446122663, 0), epoch_time_from_gps(2391, 45863, 0));
}

ZTEST(epoch_time, test_local_time_conversion)
{
	struct timeutil_sync_instant reference;
	int rc;

	/* Should boot with 01/01/2020 and TIME_SOURCE_UNKNOWN */
	zassert_equal(TIME_SOURCE_NONE, epoch_time_get_source());
	zassert_equal(epoch_time_from(1261872018, 0), epoch_time_from_ticks(0));

	/* Set new reference point */
	reference.local = 0;
	reference.ref = 1000;
	rc = epoch_time_set_reference(TIME_SOURCE_GNSS, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	/* Validate different local device times */
	zassert_equal((0 * INFUSE_EPOCH_TIME_TICKS_PER_SEC) + 1000,
		      epoch_time_from_ticks(0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal((1 * INFUSE_EPOCH_TIME_TICKS_PER_SEC) + 1000,
		      epoch_time_from_ticks(1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal((2 * INFUSE_EPOCH_TIME_TICKS_PER_SEC) + 1000,
		      epoch_time_from_ticks(2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal((0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC),
		      ticks_from_epoch_time(0 * INFUSE_EPOCH_TIME_TICKS_PER_SEC + 1000));
	zassert_equal((1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC),
		      ticks_from_epoch_time(1 * INFUSE_EPOCH_TIME_TICKS_PER_SEC + 1000));
	zassert_equal((2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC),
		      ticks_from_epoch_time(2 * INFUSE_EPOCH_TIME_TICKS_PER_SEC + 1000));
}

ZTEST(epoch_time, test_period_conversion)
{
	zassert_equal(INFUSE_EPOCH_TIME_TICKS_PER_SEC / 2,
		      k_ticks_to_epoch_near32(CONFIG_SYS_CLOCK_TICKS_PER_SEC / 2));
	zassert_equal(INFUSE_EPOCH_TIME_TICKS_PER_SEC,
		      k_ticks_to_epoch_near32(CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal(2 * INFUSE_EPOCH_TIME_TICKS_PER_SEC,
		      k_ticks_to_epoch_near32(2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));

	/* No arrays, time period is 0 */
	zassert_equal(0, epoch_period_from_array_ticks(CONFIG_SYS_CLOCK_TICKS_PER_SEC, 0));
	zassert_equal(0, epoch_period_from_array_ticks(CONFIG_SYS_CLOCK_TICKS_PER_SEC, 1));

	zassert_equal(INFUSE_EPOCH_TIME_TICKS_PER_SEC,
		      epoch_period_from_array_ticks(CONFIG_SYS_CLOCK_TICKS_PER_SEC, 2));
	zassert_equal(INFUSE_EPOCH_TIME_TICKS_PER_SEC / 2,
		      epoch_period_from_array_ticks(CONFIG_SYS_CLOCK_TICKS_PER_SEC, 3));
	zassert_equal(INFUSE_EPOCH_TIME_TICKS_PER_SEC / 3,
		      epoch_period_from_array_ticks(CONFIG_SYS_CLOCK_TICKS_PER_SEC, 4));
}

ZTEST(epoch_time, test_reference_age)
{
	struct timeutil_sync_instant reference;
	int rc;

	/* Reset the reference time to no time knowledge */
	reference.local = k_uptime_ticks();
	reference.ref = 1000;
	rc = epoch_time_set_reference(TIME_SOURCE_NONE, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	zassert_equal(UINT32_MAX, epoch_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(UINT32_MAX, epoch_time_reference_age());

	/* Reset the reference time to no time knowledge over reboot */
	reference.local = k_uptime_ticks();
	reference.ref = 1000;
	rc = epoch_time_set_reference(TIME_SOURCE_RECOVERED | TIME_SOURCE_NONE, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	zassert_equal(UINT32_MAX, epoch_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(UINT32_MAX, epoch_time_reference_age());

	/* Reference instant with valid time knowledge */
	reference.local = k_uptime_ticks();
	reference.ref = 1000;
	rc = epoch_time_set_reference(TIME_SOURCE_NTP, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	zassert_equal(0, epoch_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(1, epoch_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(2, epoch_time_reference_age());
}

ZTEST(epoch_time, test_reference_time_shift)
{
	struct timeutil_sync_instant bad = {.local = 0, .ref = 0};
	struct timeutil_sync_instant original = {.local = 10 * CONFIG_SYS_CLOCK_TICKS_PER_SEC,
						 .ref = 100 * INFUSE_EPOCH_TIME_TICKS_PER_SEC};
	struct timeutil_sync_instant shift_forward = {.local = 10 * CONFIG_SYS_CLOCK_TICKS_PER_SEC,
						      .ref = 101 * INFUSE_EPOCH_TIME_TICKS_PER_SEC};
	struct timeutil_sync_instant shift_back = {.local = 10 * CONFIG_SYS_CLOCK_TICKS_PER_SEC,
						   .ref = 99 * INFUSE_EPOCH_TIME_TICKS_PER_SEC};
	int64_t shift;

	/* Error handling */
	zassert_equal(-EINVAL, epoch_time_reference_shift(&bad, &original, &shift));
	zassert_equal(-EINVAL, epoch_time_reference_shift(&original, &bad, &shift));

	/* Reference time shifting */
	zassert_equal(0, epoch_time_reference_shift(&original, &shift_forward, &shift));
	zassert_equal(INFUSE_EPOCH_TIME_TICKS_PER_SEC, shift);
	zassert_equal(0, epoch_time_reference_shift(&original, &shift_back, &shift));
	zassert_equal(-INFUSE_EPOCH_TIME_TICKS_PER_SEC, shift);
}

struct test_cb_context {
	enum epoch_time_source source;
	struct timeutil_sync_instant old;
	struct timeutil_sync_instant new;
	int cnt;
};

static void reference_time_updated(enum epoch_time_source source, struct timeutil_sync_instant old,
				   struct timeutil_sync_instant new, void *user_ctx)
{
	struct test_cb_context *context = user_ctx;

	zassert_not_null(user_ctx);

	context->source = source;
	context->old = old;
	context->new = new;
	context->cnt += 1;
}

ZTEST(epoch_time, test_reference_changed_cb)
{
	static struct test_cb_context context;
	static struct epoch_time_cb callback = {
		.reference_time_updated = reference_time_updated,
		.user_ctx = &context,
	};
	struct timeutil_sync_instant reference;
	int rc;

	epoch_time_register_callback(&callback);

	reference.local = 100;
	reference.ref = 1000;
	rc = epoch_time_set_reference(TIME_SOURCE_NTP, &reference);
	zassert_equal(0, rc);
	zassert_equal(1, context.cnt);
	zassert_equal(100, context.new.local);
	zassert_equal(1000, context.new.ref);
	zassert_equal(TIME_SOURCE_NTP, context.source);

	reference.local = 200;
	reference.ref = 2000;
	rc = epoch_time_set_reference(TIME_SOURCE_GNSS, &reference);
	zassert_equal(0, rc);
	zassert_equal(2, context.cnt);
	zassert_equal(200, context.new.local);
	zassert_equal(2000, context.new.ref);
	zassert_equal(100, context.old.local);
	zassert_equal(1000, context.old.ref);
	zassert_equal(TIME_SOURCE_GNSS, context.source);

	reference.local = 300;
	reference.ref = 3000;
	rc = epoch_time_set_reference(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, &reference);
	zassert_equal(0, rc);
	zassert_equal(3, context.cnt);
	zassert_equal(300, context.new.local);
	zassert_equal(3000, context.new.ref);
	zassert_equal(200, context.old.local);
	zassert_equal(2000, context.old.ref);
	zassert_equal(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, context.source);
}

ZTEST(epoch_time, test_set_invalid)
{
	struct timeutil_sync_instant reference = {
		.local = 1000,
		.ref = 0,
	};
	int rc;

	rc = epoch_time_set_reference(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, &reference);
	zassert_equal(-EINVAL, rc);
}

ZTEST(epoch_time, test_get_failure)
{
	extern struct timeutil_sync_state infuse_sync_state;

	/* Manually force sync state to be invalid */
	infuse_sync_state.base.local = 1234560;
	infuse_sync_state.base.ref = 0;

	/* Sync state should be reset  */
	zassert_equal(1261872018 + 0, epoch_time_seconds(epoch_time_from_ticks(
					      0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 1, epoch_time_seconds(epoch_time_from_ticks(
					      1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 2, epoch_time_seconds(epoch_time_from_ticks(
					      2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));

	/* Manually force sync state to be invalid */
	infuse_sync_state.base.local = 1234560;
	infuse_sync_state.base.ref = 1000;
	infuse_sync_state.skew = -0.1f;

	/* Sync state should be reset  */
	zassert_equal(1261872018 + 0, epoch_time_seconds(epoch_time_from_ticks(
					      0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 1, epoch_time_seconds(epoch_time_from_ticks(
					      1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 2, epoch_time_seconds(epoch_time_from_ticks(
					      2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
}

ZTEST(epoch_time, test_application_states)
{
	struct timeutil_sync_instant original = {
		.local = 10 * CONFIG_SYS_CLOCK_TICKS_PER_SEC,
		.ref = 100 * INFUSE_EPOCH_TIME_TICKS_PER_SEC,
	};

	infuse_state_clear(INFUSE_STATE_TIME_KNOWN);

	/* State not set with untrusted time */
	zassert_equal(0, epoch_time_set_reference(TIME_SOURCE_INVALID, &original));
	zassert_false(infuse_state_get(INFUSE_STATE_TIME_KNOWN));

	/* State set with trusted time */
	zassert_equal(0, epoch_time_set_reference(TIME_SOURCE_GNSS, &original));
	zassert_true(infuse_state_get(INFUSE_STATE_TIME_KNOWN));
}

void epoch_time_before(void *ctx)
{
	epoch_time_reset();
}

ZTEST_SUITE(epoch_time, NULL, NULL, epoch_time_before, NULL, NULL);

ZTEST(timezone, test_approx_utctimezone)
{
	/* Greenwich */
	zassert_equal(0, utc_timezone_location_approximate(0));
	/* Limits of +0 */
	zassert_equal(0, utc_timezone_location_approximate(74999999));
	zassert_equal(0, utc_timezone_location_approximate(-74999999));
	/* Limits of +-1 */
	zassert_equal(1, utc_timezone_location_approximate(75000000));
	zassert_equal(1, utc_timezone_location_approximate(224999999));
	zassert_equal(-1, utc_timezone_location_approximate(-75000000));
	zassert_equal(-1, utc_timezone_location_approximate(-224999999));
	/* Start of +-2 */
	zassert_equal(2, utc_timezone_location_approximate(225000000));
	zassert_equal(-2, utc_timezone_location_approximate(-225000000));
	/* +-12 */
	zassert_equal(12, utc_timezone_location_approximate(1800000000));
	zassert_equal(-12, utc_timezone_location_approximate(-1800000000));

	/* Sydney */
	zassert_equal(10, utc_timezone_location_approximate(1512000000));
	/* New Delhi */
	zassert_equal(5, utc_timezone_location_approximate(772000000));
	/* Dakar */
	zassert_equal(-1, utc_timezone_location_approximate(-174000000));
	/* Rio de Janiro */
	zassert_equal(-3, utc_timezone_location_approximate(-432000000));
	/* Los Angeles */
	zassert_equal(-8, utc_timezone_location_approximate(-1183000000));
}

ZTEST_SUITE(timezone, NULL, NULL, NULL, NULL, NULL);
