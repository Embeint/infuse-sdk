/**
 * @file
 * @copyright 2024 Embeint Inc
 * @author Jordan Yates <jordan@embeint.com>
 *
 * SPDX-License-Identifier: LicenseRef-Embeint
 */

#include <stdint.h>

#include <zephyr/ztest.h>
#include <zephyr/kernel.h>

#include <infuse/time/civil.h>

ZTEST(civil_time, test_time_source_valid)
{
	zassert_false(civil_time_trusted_source(TIME_SOURCE_NONE, false));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_NONE, true));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_INVALID, false));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_INVALID, true));
	zassert_false(civil_time_trusted_source(33, false));
	zassert_false(civil_time_trusted_source(33, true));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NONE, false));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NONE, true));
	zassert_false(
		civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_INVALID, false));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_INVALID, true));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | 33, false));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | 33, true));

	zassert_true(civil_time_trusted_source(TIME_SOURCE_GNSS, false));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_GNSS, true));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_NTP, false));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_NTP, true));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_RPC, false));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_RPC, true));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_GNSS, false));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_GNSS, true));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NTP, false));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_NTP, true));
	zassert_false(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, false));
	zassert_true(civil_time_trusted_source(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, true));
}

static void validate_unix_conversions(struct tm *expected, uint64_t gps_time, uint64_t unix_time,
				      uint16_t subseconds)
{
	struct tm calendar;
	uint64_t civil_time;

	civil_time = civil_time_from(gps_time, subseconds);
	zassert_equal(unix_time, unix_time_from_civil(civil_time));
	zassert_equal(civil_time, civil_time_from_unix(unix_time, subseconds));

	civil_time_unix_calendar(civil_time, &calendar);
	zassert_equal(expected->tm_year, calendar.tm_year);
	zassert_equal(expected->tm_mon, calendar.tm_mon);
	zassert_equal(expected->tm_mday, calendar.tm_mday);
	zassert_equal(expected->tm_yday, calendar.tm_yday);
	zassert_equal(expected->tm_hour, calendar.tm_hour);
	zassert_equal(expected->tm_min, calendar.tm_min);
	zassert_equal(expected->tm_sec, calendar.tm_sec);
	zassert_equal(expected->tm_wday, calendar.tm_wday);
}

/* Equivalent times are generated by `hifitime_generator.py`.
 * hifitime is a formally verified time library and should be trusted over websites.
 */
ZTEST(civil_time, test_unix_conversions)
{
	struct tm expected;

	/* 2017-01-01T00:00:00 UTC */
	expected.tm_year = 117;
	expected.tm_mon = 0;
	expected.tm_mday = 1;
	expected.tm_yday = 0;
	expected.tm_hour = 0;
	expected.tm_min = 0;
	expected.tm_sec = 0;
	expected.tm_wday = 0;
	validate_unix_conversions(&expected, 1167264018, 1483228800, 0);

	/* 2020-01-01T00:00:00 UTC */
	expected.tm_year = 120;
	expected.tm_mon = 0;
	expected.tm_mday = 1;
	expected.tm_yday = 0;
	expected.tm_hour = 0;
	expected.tm_min = 0;
	expected.tm_sec = 0;
	expected.tm_wday = 3;
	validate_unix_conversions(&expected, 1261872018, 1577836800, 0);

	/* 2024-07-02T12:43:01 UTC */
	expected.tm_year = 124;
	expected.tm_mon = 6;
	expected.tm_mday = 2;
	expected.tm_yday = 183;
	expected.tm_hour = 12;
	expected.tm_min = 43;
	expected.tm_sec = 1;
	expected.tm_wday = 2;
	validate_unix_conversions(&expected, 1403959399, 1719924181, 0);

	/* 2024-07-02T12:43:01 UTC + (1324/65536) */
	expected.tm_year = 124;
	expected.tm_mon = 6;
	expected.tm_mday = 2;
	expected.tm_yday = 183;
	expected.tm_hour = 12;
	expected.tm_min = 43;
	expected.tm_sec = 1;
	expected.tm_wday = 2;
	validate_unix_conversions(&expected, 1403959399, 1719924181, 1324);
}

static void validate_internal(uint64_t civil_time)
{
	uint64_t seconds, subseconds;

	seconds = civil_time_seconds(civil_time);
	subseconds = civil_time_subseconds(civil_time);

	zassert_not_equal(civil_time, seconds);
	zassert_not_equal(civil_time, subseconds);
	zassert_equal(civil_time, civil_time_from(seconds, subseconds));
}

ZTEST(civil_time, test_internal_conversions)
{
	/* Validate at a random time across the whole subsecond range */
	for (int i = 0; i < 100000; i++) {
		validate_internal(12345678910 + i);
	}

	zassert_equal(0, civil_time_milliseconds(0));
	zassert_equal(250, civil_time_milliseconds((UINT16_MAX + 1) / 4));
	zassert_equal(333, civil_time_milliseconds((UINT16_MAX + 1) / 3));
	zassert_equal(500, civil_time_milliseconds((UINT16_MAX + 1) / 2));
	zassert_equal(999, civil_time_milliseconds(UINT16_MAX));
	zassert_equal(0, civil_time_milliseconds(UINT16_MAX + 1));
}

ZTEST(civil_time, test_gps_conversions)
{
	/* Time equivalents generated from https://gnsscalc.com/ */
	zassert_equal(civil_time_from(1393460764, 0), civil_time_from_gps(2304, 1564, 0));
	zassert_equal(civil_time_from(1396138875, 0), civil_time_from_gps(2308, 260475, 0));
	zassert_equal(civil_time_from(1446122663, 0), civil_time_from_gps(2391, 45863, 0));
}

ZTEST(civil_time, test_local_time_conversion)
{
	struct timeutil_sync_instant reference;
	int rc;

	/* Should boot with 01/01/2020 and TIME_SOURCE_UNKNOWN */
	zassert_equal(TIME_SOURCE_NONE, civil_time_get_source());
	zassert_equal(civil_time_from(1261872018, 0), civil_time_from_ticks(0));

	/* Set new reference point */
	reference.local = 0;
	reference.ref = 1000;
	rc = civil_time_set_reference(TIME_SOURCE_GNSS, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	/* Validate different local device times */
	zassert_equal((0 * INFUSE_CIVIL_TIME_TICKS_PER_SEC) + 1000,
		      civil_time_from_ticks(0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal((1 * INFUSE_CIVIL_TIME_TICKS_PER_SEC) + 1000,
		      civil_time_from_ticks(1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal((2 * INFUSE_CIVIL_TIME_TICKS_PER_SEC) + 1000,
		      civil_time_from_ticks(2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC));
	zassert_equal((0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC),
		      ticks_from_civil_time(0 * INFUSE_CIVIL_TIME_TICKS_PER_SEC + 1000));
	zassert_equal((1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC),
		      ticks_from_civil_time(1 * INFUSE_CIVIL_TIME_TICKS_PER_SEC + 1000));
	zassert_equal((2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC),
		      ticks_from_civil_time(2 * INFUSE_CIVIL_TIME_TICKS_PER_SEC + 1000));
}

ZTEST(civil_time, test_reference_age)
{
	struct timeutil_sync_instant reference;
	int rc;

	/* Reset the reference time to no time knowledge */
	reference.local = k_uptime_ticks();
	reference.ref = 1000;
	rc = civil_time_set_reference(TIME_SOURCE_NONE, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	zassert_equal(UINT32_MAX, civil_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(UINT32_MAX, civil_time_reference_age());

	/* Reset the reference time to no time knowledge over reboot */
	reference.local = k_uptime_ticks();
	reference.ref = 1000;
	rc = civil_time_set_reference(TIME_SOURCE_RECOVERED | TIME_SOURCE_NONE, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	zassert_equal(UINT32_MAX, civil_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(UINT32_MAX, civil_time_reference_age());

	/* Reference instant with valid time knowledge */
	reference.local = k_uptime_ticks();
	reference.ref = 1000;
	rc = civil_time_set_reference(TIME_SOURCE_NTP, &reference);
	zassert_equal(0, rc, "Set reference instant failed");

	zassert_equal(0, civil_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(1, civil_time_reference_age());
	k_sleep(K_SECONDS(1));
	zassert_equal(2, civil_time_reference_age());
}

struct test_cb_context {
	enum civil_time_source source;
	struct timeutil_sync_instant old;
	struct timeutil_sync_instant new;
	int cnt;
};

static void reference_time_updated(enum civil_time_source source, struct timeutil_sync_instant old,
				   struct timeutil_sync_instant new, void *user_ctx)
{
	struct test_cb_context *context = user_ctx;

	zassert_not_null(user_ctx);

	context->source = source;
	context->old = old;
	context->new = new;
	context->cnt += 1;
}

ZTEST(civil_time, test_reference_changed_cb)
{
	static struct test_cb_context context;
	static struct civil_time_cb callback = {
		.reference_time_updated = reference_time_updated,
		.user_ctx = &context,
	};
	struct timeutil_sync_instant reference;
	int rc;

	civil_time_register_callback(&callback);

	reference.local = 100;
	reference.ref = 1000;
	rc = civil_time_set_reference(TIME_SOURCE_NTP, &reference);
	zassert_equal(0, rc);
	zassert_equal(1, context.cnt);
	zassert_equal(100, context.new.local);
	zassert_equal(1000, context.new.ref);
	zassert_equal(TIME_SOURCE_NTP, context.source);

	reference.local = 200;
	reference.ref = 2000;
	rc = civil_time_set_reference(TIME_SOURCE_GNSS, &reference);
	zassert_equal(0, rc);
	zassert_equal(2, context.cnt);
	zassert_equal(200, context.new.local);
	zassert_equal(2000, context.new.ref);
	zassert_equal(100, context.old.local);
	zassert_equal(1000, context.old.ref);
	zassert_equal(TIME_SOURCE_GNSS, context.source);

	reference.local = 300;
	reference.ref = 3000;
	rc = civil_time_set_reference(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, &reference);
	zassert_equal(0, rc);
	zassert_equal(3, context.cnt);
	zassert_equal(300, context.new.local);
	zassert_equal(3000, context.new.ref);
	zassert_equal(200, context.old.local);
	zassert_equal(2000, context.old.ref);
	zassert_equal(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, context.source);
}

ZTEST(civil_time, test_set_invalid)
{
	struct timeutil_sync_instant reference = {
		.local = 1000,
		.ref = 0,
	};
	int rc;

	rc = civil_time_set_reference(TIME_SOURCE_RECOVERED | TIME_SOURCE_RPC, &reference);
	zassert_equal(-EINVAL, rc);
}

ZTEST(civil_time, test_get_failure)
{
	extern struct timeutil_sync_state infuse_sync_state;

	/* Manually force sync state to be invalid */
	infuse_sync_state.base.local = 1234560;
	infuse_sync_state.base.ref = 0;

	/* Sync state should be reset  */
	zassert_equal(1261872018 + 0, civil_time_seconds(civil_time_from_ticks(
					      0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 1, civil_time_seconds(civil_time_from_ticks(
					      1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 2, civil_time_seconds(civil_time_from_ticks(
					      2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));

	/* Manually force sync state to be invalid */
	infuse_sync_state.base.local = 1234560;
	infuse_sync_state.base.ref = 1000;
	infuse_sync_state.skew = -0.1f;

	/* Sync state should be reset  */
	zassert_equal(1261872018 + 0, civil_time_seconds(civil_time_from_ticks(
					      0 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 1, civil_time_seconds(civil_time_from_ticks(
					      1 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
	zassert_equal(1261872018 + 2, civil_time_seconds(civil_time_from_ticks(
					      2 * CONFIG_SYS_CLOCK_TICKS_PER_SEC)));
}

ZTEST_SUITE(civil_time, NULL, NULL, NULL, NULL, NULL);
