/**
 * @file
 * @brief Autogenerated RPC command runner
 * @copyright 2024 Embeint Inc
 * @author scripts/west_commands/cloudgen.py
 *
 * SPDX-License-Identifier: LicenseRef-Embeint
 */

#include <stdbool.h>

#include <zephyr/toolchain.h>
#include <zephyr/net/buf.h>

#include <infuse/epacket/interface.h>
#include <infuse/epacket/packet.h>
#include <infuse/rpc/types.h>

#include "commands/commands.h"

static bool command_freed;

void rpc_command_runner_request_unref(struct net_buf *request)
{
	net_buf_unref(request);
	command_freed = true;
}

void rpc_command_runner(struct net_buf *request)
{
	struct epacket_rx_metadata *metadata = net_buf_user_data(request);
	const struct device *interface = metadata->interface;
	struct infuse_rpc_req_header *req_header = (void *)request->data;
	struct infuse_rpc_rsp_header *rsp_header;
	struct net_buf *response = NULL;
	enum epacket_auth auth = metadata->auth;
	uint32_t request_id = req_header->request_id;
	int16_t rc = -EACCES;

	/* Reset command freed state */
	command_freed = false;

	/* clang-format off */
	switch (req_header->command_id) {
#ifdef CONFIG_INFUSE_RPC_COMMAND_REBOOT
	case RPC_ID_REBOOT:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_REBOOT_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_reboot(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_REBOOT */
#ifdef CONFIG_INFUSE_RPC_COMMAND_FAULT
	case RPC_ID_FAULT:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_FAULT_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_fault(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_FAULT */
#ifdef CONFIG_INFUSE_RPC_COMMAND_TIME_GET
	case RPC_ID_TIME_GET:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_TIME_GET_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_time_get(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_TIME_GET */
#ifdef CONFIG_INFUSE_RPC_COMMAND_TIME_SET
	case RPC_ID_TIME_SET:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_TIME_SET_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_time_set(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_TIME_SET */
#ifdef CONFIG_INFUSE_RPC_COMMAND_KV_WRITE
	case RPC_ID_KV_WRITE:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_KV_WRITE_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_kv_write(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_KV_WRITE */
#ifdef CONFIG_INFUSE_RPC_COMMAND_KV_READ
	case RPC_ID_KV_READ:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_KV_READ_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_kv_read(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_KV_READ */
#ifdef CONFIG_INFUSE_RPC_COMMAND_WIFI_SCAN
	case RPC_ID_WIFI_SCAN:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_WIFI_SCAN_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_wifi_scan(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_WIFI_SCAN */
#ifdef CONFIG_INFUSE_RPC_COMMAND_WIFI_STATE
	case RPC_ID_WIFI_STATE:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_WIFI_STATE_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_wifi_state(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_WIFI_STATE */
#ifdef CONFIG_INFUSE_RPC_COMMAND_DATA_SENDER
	case RPC_ID_DATA_SENDER:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_DATA_SENDER_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_data_sender(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_DATA_SENDER */
#ifdef CONFIG_INFUSE_RPC_COMMAND_DATA_RECEIVER
	case RPC_ID_DATA_RECEIVER:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_DATA_RECEIVER_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_data_receiver(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_DATA_RECEIVER */
#ifdef CONFIG_INFUSE_RPC_COMMAND_ECHO
	case RPC_ID_ECHO:
		if (auth >= CONFIG_INFUSE_RPC_COMMAND_ECHO_REQUIRED_AUTH) { /* GCOVR_EXCL_BR_LINE */
			response = rpc_command_echo(request);
		}
		break;
#endif /* CONFIG_INFUSE_RPC_COMMAND_ECHO */
	default:
		rc = -ENOTSUP;
	};
	/* clang-format on */

	/* Free the request */
	if (!command_freed) {
		net_buf_unref(request);
	}

	if (response == NULL) {
		/* No command run, alloc the response packet */
		response = epacket_alloc_tx_for_interface(interface, K_FOREVER);
		rsp_header = net_buf_add(response, sizeof(*rsp_header));
		rsp_header->return_code = rc;
	} else {
		rsp_header = (void *)response->data;
	}
	rsp_header->request_id = request_id;

	/* Metadata and core response info */
	epacket_set_tx_metadata(response, auth, 0x00, INFUSE_RPC_RSP);

	/* Push response back over incoming interface */
	epacket_queue(interface, response);
}
